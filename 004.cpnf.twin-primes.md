# **Twin Primes in the CPNF**

## **Twin-Index Representation**

**Twin-Index Transformation**

After removing multiples of 2 and 3, all survivors greater than 3 take the form 6n ± 1. This observation provides a natural representation for twin survivor candidates:

- **Twin candidate at index n**: The pair T_n = (6n−1, 6n+1)
- **Twin-index**: An integer n ≥ 1 such that both 6n−1 and 6n+1 are candidates
- **Certification predicate**: Index n is certified at stage k if both 6n−1 and 6n+1 survive trial division by all blockers in B_k with p ≤ √(6n+1)

This representation transforms the problem from searching for pairs of survivors to certifying single indices—a crucial simplification that simplifies the analysis.

## **Twin Sieve and Certification Process**

**Twin Sieve Operator**

Given the current blocker set B_k and a bound W, the twin sieve identifies all twin-indices within the certification window:

\[
TS(B_k, W) = \{n \le W : \forall p \in B_k, (6n-1) \not\equiv 0 \ (\text{mod } p) \text{ and } (6n+1) \not\equiv 0 \ (\text{mod } p)\}
\]

**Certification Window**

At stage k, the certification window is determined by the largest known blocker y_k = max(B_k). Since we must test divisors up to √(6n+1), and the largest available divisor is y_k, we require √(6n+1) ≤ y_k, which gives:

\[
W_k = \lfloor (y_k^2 - 1)/6 \rfloor
\]

## **Twin Sifting Process Algorithm**

The twin sifting process maintains state across stages, accumulating certified twin-indices:

```javascript
function twin_sifting_process():
    B = {2, 3}                     // initial blockers
    T = {}                         // no twin indices certified yet

    while true:
        // --- Completion phase ---
        // Ensure B contains all survivors up to 6*maxIndex(T)+1
        while (max(B) < 6*maxIndex(T) + 1):
            B = B ∪ {min(ordinarySieve(B))}

        // --- Twin search phase ---
        y = max(B)
        W = floor((y² - 1) / 6)   // certification window bound

        // Find minimal twin index in window not yet in T
        candidates = {n ≤ W : n ∉ T ∧ (∀p∈B, p∤(6n-1) ∧ p∤(6n+1))}

        if candidates ≠ ∅:
            n = min(candidates)
            T = T ∪ {n}           // Certify twin index
        else:
            // No twin found: expand blockers
            B = B ∪ {min(ordinarySieve(B))}
```

### **Key Components and Invariants**

1. **Completion Invariant**: Before each twin search, the blocker set B contains **all survivors** ≤ 6·max(T) + 1, where max(T) = 0 if T is empty.

2. **Certification Condition**: An index n is certified only when:

   - n ≤ W (within the certification window)
   - Both 6n-1 and 6n+1 survive division by all blockers in B
   - The completion invariant ensures B contains all necessary divisors for verification

3. **Progress Guarantee**: Each iteration either:
   - Certifies a new twin index n (adding it to T)
   - Expands B by adding the minimal survivor from ordinarySieve(B)

### **Process Dynamics**

The algorithm maintains clear separation of concerns:

- **Completion Phase**: Ensures the blocker set contains all survivors necessary to verify potential twin indices up to the current maximum
- **Twin-Search Phase**: Searches the certification window for the smallest uncertified index that survives all current blockers

The certification window grows quadratically with max(B), while the set of blockers grows only logarithmically. This growth-rate mismatch is central to proving non-termination.

### The Endless Chase Objection

At first glance, the twin-index sifting process appears to parallel the ordinary CPNF sieve of Part I. In that setting, non-termination follows directly from the ability to select the minimal remaining candidate and certify it as a survivor. The logic is straightforward because the sieve acts directly on integers, and minimality suffices to guarantee correctness.

In the twin-index setting, the situation is more subtle. The sieve now operates indirectly: the ordinary CPNF sieve runs in the background while the process itself is carried out in index space. Certification is constrained by the certification window, which guarantees non-compositeness only for indices n ≤ W_k. Outside this window, candidates may survive all current blockers yet still be composite due to undiscovered divisors. Since the twin sifting process does not permit backtracking, any certified index must be correct at the moment of certification.

This leads to the central concern of Part II.

> **Endless Chase Scenario.**  
> Is it possible that, after some finite stage, all surviving twin candidates lie outside the certification window indefinitely, so that no new twin-index can ever be safely certified—even though the process itself continues?

In other words, could the system enter a pathological regime in which the process progresses stage by stage, yet twin certification stagnates permanently?

We show that this scenario is impossible, for structural reasons intrinsic to the sieve.

---
