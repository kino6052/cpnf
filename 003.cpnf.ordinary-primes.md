## The CPNF for Ordinary Primes

### Basic Framework and Definitions

**Computational Primality**

Let ℕ⁺ denote positive integers. In the CPNF, primality emerges not as an inherent property but as a fact of surviving a stagewise elimination process. We define the core components:

- **Blocker set B_k**: The finite set of primes certified by the CPNF through stage k. Initially, B₀ = ∅.
- **Candidate set**: Integers not eliminated by blockers in B_k.
- **Sieve operator**:
  \[
  S(B_k, \mathbb{N}^+) = \{n \in \mathbb{N}^+ : \forall p \in B_k, n \not\equiv 0 \pmod{p}\}
  \]
  This operator implements the local divisibility tests: for each blocker p, it removes all multiples of p.

### Stage-Based Generation

The ordinary CPNF proceeds in discrete stages:

1. **Initialization**: B₀ = ∅, candidates = all integers ≥ 2.
2. **Stage k**:
   - Compute survivors = S(B\_{k−1}, ℕ⁺)
   - Select the minimal survivor n ∈ survivors
   - Add n to B_k (certify as prime)
3. **Certification**: Each selected number n comes with a finite certificate B\_{k−1}—the list of blockers it survived.

**Algorithm (`siftingProcess`)**:

```
function siftingProcess():
  B = empty set
  numbers = all integers >= 2
  while true:
    survivors = sieve(B, numbers)  // S(B, N^+)
    if survivors is empty: break
    n = min(survivors)
    B = B union {n}
    record n as certified prime
```

This mirrors the Sieve of Eratosthenes but with crucial differences: it proceeds stagewise, maintains explicit certificates, and selects only one survivor per stage.

### Elementary Properties and Theorems

**Theorem (No Composite Selection)**  
No composite integer is ever selected by the CPNF process.

_Proof._ Suppose a composite number m were selected at some stage. Let p be its smallest prime divisor. Since p < m and p divides m, p would have been selected earlier (as the minimal survivor not divisible by any previous blocker). Then p ∈ B would block m, contradicting m’s selection as a survivor. ∎

**Theorem (Non-Termination)**  
The CPNF process for ordinary primes never terminates.

_Proof._ Suppose only finitely many primes p₁, …, p_m were certified. Consider M = p₁ p₂ ⋯ p_m + 1. This number is not divisible by any p_i, so M ∈ S({p₁,…,p_m}, ℕ⁺). Since M > max(p_i), it (or a smaller candidate) would be selected as the next minimal survivor, contradicting the assumption of finiteness. This mirrors Euclid’s classical proof. ∎

### Implementation Correspondence

The provided code implements these definitions precisely:

```javascript
// Sieve operator S(B, N^+)
const sieve = (blockers, numbers) => {
  return numbers.filter(
    (number) => !blockers.find((blocker) => number % blocker === 0)
  );
};

// Stagewise sifting process (simplified)
const siftingProcess = (numbers, iterations) => {
  const blockers = [2, 3]; // Initial blockers (survivors)
  const result = [];

  for (let stage = 0; stage < iterations; stage++) {
    const survivors = sieve(blockers, numbers);
    if (survivors.length === 0) break;

    const nextBlocker = survivors[0]; // Minimal survivor
    blockers.push(nextBlocker); // Certification
    result.push(nextBlocker);
  }
  return result; // CPNF survivors
};
```

---
