## Twin Primes in the CPNF

### Twin-Index Representation

**Twin-Index Transformation**

After removing multiples of 2 and 3, all primes greater than 3 take the form 6n ± 1. This observation provides a natural representation for twin prime candidates:

- **Twin candidate at index n**: The pair T_n = (6n−1, 6n+1)
- **Twin-index**: An integer n ≥ 1 such that both 6n−1 and 6n+1 are candidates
- **Certification predicate**: Index n is certified at stage k if both 6n−1 and 6n+1 survive trial division by all blockers in B_k with p ≤ √(6n+1)

This representation transforms the problem from searching for pairs of primes to certifying single indices—a crucial simplification that enables computational analysis.

### Twin Sieve and Certification Process

**Twin Sieve Operator**

Given the current blocker set B_k and a bound W, the twin sieve identifies all twin-indices within the certification window:

\[
TS(B_k, W) = \{n \le W : \forall p \in B_k, (6n-1) \not\equiv 0 \ (\text{mod } p) \text{ and } (6n+1) \not\equiv 0 \ (\text{mod } p)\}
\]

**Certification Window**

At stage k, the certification window is determined by the largest known prime y_k = max(B_k). Since we must test divisors up to √(6n+1), and the largest available divisor is y_k, we require √(6n+1) ≤ y_k, which gives:

\[
W_k = \lfloor (y_k^2 - 1)/6 \rfloor
\]

**Twin Certification Function**

The function `twin_sieve(stage_k, previouslyIdentifiedTwinIndices, W)` operates as follows:

1. Compute B_k (blockers up to stage k)
2. Compute W_k based on y_k = max(B_k)
3. For each n ≤ W_k not in previouslyIdentifiedTwinIndices:
   - Test if both 6n−1 and 6n+1 are divisible by any p ∈ B_k
   - If both survive, return n as a new certified twin-index
4. If no new twin-index is found, return null

### Twin Sifting Process Algorithm

The twin sifting process maintains state across stages, accumulating certified twin-indices:

```javascript
function twin_sifting_process():
   function twin_sifting_process():
    B = {2, 3}                     // initial blockers (primes 2 and 3)
    T = {}                         // no twin indices certified yet

    while true:
        // --- Completion phase: ensure B contains all primes up to 6*maxIndex(T)+1 ---
        // We maintain the invariant: B contains every prime ≤ 6*maxIndex(T)+1
        // where maxIndex(T) is the largest certified twin index (0 if T is empty)
        while (max(B) < 6*max(T) + 1):
            B = B ∪ {min(ordinarySieve(B))}

        // --- Twin search phase ---
        y = max(B)
        W = floor((y² - 1) / 6)   // certification window bound

        // Find minimal twin index in window not yet in T
        candidates = {n ≤ W : n ∉ T ∧ (∀p∈B, p∤(6n-1) ∧ p∤(6n+1))}

        if candidates ≠ ∅:
            n = min(candidates)
            T = T ∪ {n}           // Certify twin index
        else:
            // No twin found: expand blockers by adding next prime
            B = B ∪ {min(ordinarySieve(B))}
```

### **Key Properties**

1. **Completeness Guarantee**: The completion phase ensures that before each twin search, the blocker set \(B\) contains all blockers ≤ max(B).

2. **Progress**: The process never terminates; it either certifies a new twin index or adds an ordinary prime to expand the blocker set and window.

### **Process Dynamics**

The algorithm alternates between:

- **Twin certification mode**: When an admissible twin index is found in the window, it is certified and its larger prime is added to \(B\).
- **Blocker expansion mode**: When no twin is found, the next ordinary prime is added to \(B\), which expands the certification window for future searches.

More blockers enable larger certification windows, while larger windows provide more opportunities for twin certification.

### The Endless Chase Objection

At first glance, the twin-index sifting process appears to parallel the ordinary CPNF sieve of Part I. In that setting, non-termination follows directly from the ability to select the minimal remaining candidate and certify it as a survivor. The logic is straightforward because the sieve acts directly on integers, and minimality suffices to guarantee correctness.

In the twin-index setting, the situation is more subtle. The sieve now operates indirectly: the ordinary CPNF sieve runs in the background while the process itself is carried out in index space. Certification is constrained by the certification window, which guarantees non-compositeness only for indices n ≤ W_k. Outside this window, candidates may survive all current blockers yet still be composite due to undiscovered divisors. Since the twin sifting process does not permit backtracking, any certified index must be correct at the moment of certification.

This leads to the central concern of Part II.

> **Endless Chase Scenario.**  
> Is it possible that, after some finite stage, all surviving twin candidates lie outside the certification window indefinitely, so that no new twin-index can ever be safely certified—even though the process itself continues?

In other words, could the system enter a pathological regime in which the process progresses stage by stage, yet twin certification stagnates permanently?

We show that this scenario is impossible, for structural reasons intrinsic to the sieve.

---
